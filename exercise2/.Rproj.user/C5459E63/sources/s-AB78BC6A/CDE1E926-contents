---
title: 'Series temporales, práctica 1: conjunto de datos meteorológicos de Granada-aeropuerto Chauchina medidos por AEMET.'
author: "Carlos Manuel Sequí Sánchez"
output: pdf_document
---

\section{Problema 2.  ¿Qué valores de temperatura máxima, a escala diaria, se espera para la primera semana de Marzo de 2018?}
 
 
Primeramente leemos el conjunto de datos que contiene los siguientes atributos:  
- Columna 1 : Identificador Estación   
- Columna 2 : Fecha   
- Columna 3 : Temperatura Máxima (ºC)  
- Columna 4 : Hora Temperatura Máxima   
- Columna 5 : Temperatura mínima (ºC)  
- Columna 6 : Hora Temperatura mínima   
- Columna 7 : Temperatura Media (ºC)  
- Columna 8 : Racha máxima de viento (Km/h)  
- Columna 9 : Hora de Racha Máxima   
- Columna 10 : Velocidad media de Viento (Km/h)  
- Columna 11 : Hora de Velocidad Máxima de viento     
- Columna 12 : Precipitacion Total diaria (mm)   
- Columna 13 : Precipitacion de 0 a 6 horas (mm)  
- Columna 14 : Precipitacion de 6 a 12 horas (mm)  
- Columna 15 : Precipitacion de 12 a 18 horas (mm)  
- Columna 16 : Precipitacion de 18 a 24 horas (mm)  

Librerías...
```{r}
library(tseries)
library(dplyr)
library(lubridate)
```

Leemos el dataset y, como solo nos interesa la fecha y la temperatura máxima nos quedamos con tan solo esos datos.
```{r}
datos = read.csv("5530E.csv", header = TRUE, sep=";")
datos = datos[,c("Fecha","Tmax")]
datos$Fecha = as.Date(datos$Fecha)
```


Veamos los valores NA...
```{r} 
apply(datos, 2, function(atributo){sum(is.na(atributo))})
```

Imputamos el valor de la mediana en las temperaturas máximas donde existan valores perdidos con el fin de no tergiversar los datos eliminando días del año.
```{r}
datos$Tmax[is.na(datos$Tmax)] = median(datos$Tmax, na.rm = T)
```

Obtenemos ahora la cantidad de datos a predecir y la serie temporal en sí
```{r}
Npred = 7 # cantidad de datos a predecir (temperaturas máximas de marzo y abril)
serie = datos$Tmax
serie.ts = ts(serie, frequency = 365) # frequency set to 12 to set stationality each 12 months
plot(decompose(serie.ts))
```

Observamos en la gráfica:  
-los valores de la serie  
-la tendencia calculada mediante filtros  
-la estacionalidad repetida cada 12 instantes de tiempo
-lo que queda de la serie al eliminar tendencia y estacionalidad


Probamos, como hemos hecho en experimentos anteriores, a realizar una transformación logarítmica de la serie para reducir la varianza y así evitar problemas con el cálculo de la estacionariedad:
```{r}
serie.ts.log = log(serie.ts) 
serie.log = log(serie) 
plot(decompose(serie.ts.log))
```

El cambio es relativamente muy pequeño, es posible que tenga mucho que ver la gran cantidad de datos, siendo difícil distinguir la variación entre la gráfica anterior y esta. Aún así, por precaución, tomaremos esta serie por válida.  

Observamos los datos de estacionalidad que nos servirán en el futuro para eliminársela a la serie temporal.
```{r}
head(decompose(serie.ts.log)$seasonal)
```

Por simplicidad en el uso de la nomenclatura utilizare la variable serie en lugar de serie.log
```{r}
serie = serie.log
```


Calculamos los instantes de tiempo de la serie
```{r}
# para train
tiempo = 1:length(serie.ts.log)
# para test
tiempoTs = (tiempo[length(tiempo)]+1):(tiempo[length(tiempo)]+Npred)
```


Representamos la serie
```{r}
plot.ts(serie, xlim=c(1, tiempoTs[length(tiempoTs)]))
```




Modelamos la tendencia, la cual podemos aparentemente ajustarla de forma lineal, sabiendo que:   
serie = parametroA * tiempo + parametroB   
Con ayuda de la función lm calculamos dichos parámetros: 

```{r}
parametros.H1 = lm(serie ~tiempo) 
parametros.H1
```

Tomamos Intercept como termino independiente (parametroB) y el otro como el que multiplica al tiempo para poder calcular la serie (parametroA). Para modelar la tendencia usamos la fórmula descrita antes:
```{r}
# tendencia estimada para los datos de train 
tendEstimadaTr = parametros.H1$coefficients[1] + tiempo*parametros.H1$coefficients[2] 
# tendencia estimada para las predicciones de test 
tendEstimadaTs = parametros.H1$coefficients[1] + tiempoTs*parametros.H1$coefficients[2] 
```



Comprobamos visualmente si la tendencia se ajusta al modelo que tenemos de la serie temporal: 


```{r}
plot.ts(serie, xlim=c(1, tiempoTs[length(tiempoTs)])) 
lines(tiempo, tendEstimadaTr, col = "blue") 
lines(tiempoTs, tendEstimadaTs, col = "green")
```

Podemos observar los ajustes tanto de la tendencia para los datos de train como de la estimada para los datos de test.  

A continuación procedemos a validar de forma estadística que el modelo lineal creado sea correcto. Con el test de Jarque Bera comprobamos si los errores siguen una distribución normal a lo largo del tiempo.
```{r}
JB = jarque.bera.test(parametros.H1$residuals)
JB
```






Como el valor del p-value es inferior a 0.05, no podemos asegurar que los residuos no guarden una diferencia significativa con los datos de una distribución normal, por lo que procedemos a intentar ajustar la tendencia con otro modelo, esta vez cuadrático.





```{r}
# calculo de parámetros
parametros.H1 = lm(serie ~tiempo + I(tiempo^2)) 
parametros.H1

# tendencia estimada para los datos de train 
tendEstimadaTr = parametros.H1$coefficients[1] + tiempo*parametros.H1$coefficients[2]  + tiempo*parametros.H1$coefficients[3] 
# tendencia estimada para las predicciones de test 
tendEstimadaTs = parametros.H1$coefficients[1] + tiempoTs*parametros.H1$coefficients[2]  + tiempoTs*parametros.H1$coefficients[3] 
```



Comprobamos visualmente si la tendencia se ajusta al modelo que tenemos de la serie temporal: 


```{r}
plot.ts(serie, xlim=c(1, tiempoTs[length(tiempoTs)])) 
lines(tiempo, tendEstimadaTr, col = "blue") 
lines(tiempoTs, tendEstimadaTs, col = "green")
```

Validamos de forma estadística de nuevo con el test de Jarque Bera, con el que comprobamos si los errores siguen una distribución normal a lo largo del tiempo.
```{r}
JB = jarque.bera.test(parametros.H1$residuals)
JB
```

Tras probar con estos dos modelos, me decido por realizar diferenciación tantas veces como sea necesario con tal de suazivar la tendencia:



Probamos de nuevo...
```{r}
# calculo de parametros
parametros.H1 = lm(serie ~tiempo)

# tendencia estimada para los datos de train 
tendEstimadaTr = parametros.H1$coefficients[1] + tiempo*parametros.H1$coefficients[2] 
# tendencia estimada para las predicciones de test 
tendEstimadaTs = parametros.H1$coefficients[1] + tiempoTs*parametros.H1$coefficients[2] 

# representacion de la tendencia sobre la serie
plot.ts(serie, xlim=c(1, tiempoTs[length(tiempoTs)])) 
lines(tiempo, tendEstimadaTr, col = "blue") 
lines(tiempoTs, tendEstimadaTs, col = "green")

# test de normalizacion Jarque Bera
JB = jarque.bera.test(parametros.H1$residuals)
JB
```


















